From stefan.muenkner@zdv.uni-tuebingen.de Tue Jan 11 12:00:51 2000
Return-Path: <stefan.muenkner@zdv.uni-tuebingen.de>
Delivered-To: thecivvie@tcob1.tele2.co.uk
Received: from localhost (localhost [127.0.0.1])
	by tcob1.tele2.co.uk (Postfix) with ESMTP id 066D66FA3
	for <thecivvie@tcob1.tele2.co.uk>; Tue, 11 Jan 2000 12:00:43 +0000 (GMT)
Delivered-To: thecivvie@softhome.net
Received: from pop.softhome.net
	by localhost with POP3 (fetchmail-5.2.3)
	for thecivvie@tcob1.tele2.co.uk (single-drop); Tue, 11 Jan 2000 12:00:47 +0000 (GMT)
Received: (qmail 32218 invoked by uid 417); 11 Jan 2000 11:19:43 -0000
Received: from calvin.zdv.uni-tuebingen.de (134.2.3.98)
  by mx0b.softhome.net with SMTP; 11 Jan 2000 11:19:43 -0000
Received: (from stefan@localhost)
	by calvin.zdv.uni-tuebingen.de (8.9.3/8.9.3/SuSE Linux 8.9.3-0.1) id MAA02861;
	Tue, 11 Jan 2000 12:18:36 +0100
Date: Tue, 11 Jan 2000 12:18:36 +0100
Message-Id: <200001111118.MAA02861@calvin.zdv.uni-tuebingen.de>
X-Authentication-Warning: calvin.zdv.uni-tuebingen.de: stefan set sender to stefan.muenkner@zdv.uni-tuebingen.de using -f
From: Stefan Muenkner <stefan.muenkner@zdv.uni-tuebingen.de>
To: Sean Rima <thecivvie@softhome.net>
Subject: vacatio and problems with case in strings
Organization: Zentrum fuer Datenverarbeitung, Universitaet Tuebingen
X-Mailer: GNU emacs 20.4.1
Mime-Version: 1.0 (generated by tm-edit 7.106)
Content-Type: multipart/mixed;
 boundary="Multipart_Tue_Jan_11_12:18:35_2000-1"
Content-Transfer-Encoding: 7bit
Status: RO
Content-Length: 5029
Lines: 177

--Multipart_Tue_Jan_11_12:18:35_2000-1
Content-Type: text/plain; charset=US-ASCII


Hi,

Harald Milz of SuSE Munich told me, you are the official
maintainer of vacation now.

We experienced problems in vacation related to case sensitivity
in the mail header.  The problem was that a forward line like:

\zrims01, "|/tmp/vacation -r -a stefan.muenkner zrims01"

would fail to send a vacation if the To:-line was written:

 To: Stefan.Muenkner@zdv.uni-tuebingen.de

The problem was caused in nsearch where the first characters were
compared without ignoring the case. Since capitalization should
be of no interest for any field in the mail header I changed
vacation.c accordingly.  I also fixed some other comparisons that
were case sensitive where the RFC(s) allow any case in mail
headers. The patch file was diffed against vacation-1.2.0 out of
SuSE 6.3.

Best regards,

 Stefan Muenkner

     Stefan Muenkner                |   stefan.muenkner@zdv.uni-tuebingen.de
     Zentrum fuer Datenverarbeitung |
     Universitaet Tuebingen         |
     Waechterstrasse 76             |   phone +49 7071 29-70208
     D-72074 Tuebingen              |   fax   +49 7071 29--5912
     Germany                        |   
     





--Multipart_Tue_Jan_11_12:18:35_2000-1
Content-Type: application/octet-stream; type=patch
Content-Disposition: attachment; filename="vacation.c.patch"
Content-Transfer-Encoding: 7bit

*** vacation.c.orig	Tue Jan 11 11:59:10 2000
--- vacation.c	Tue Jan 11 12:03:31 2000
***************
*** 215,224 ****
  
    cont = tome = 0;
    while (fgets(buf, sizeof(buf), stdin) && *buf != '\n')
!     switch(*buf) {
      case 'F':		/* "From: " or "From "*/
        cont = 0;
!       if (!strncmp(buf, "From:", 5)) {     /* "From:" */
  	if ((p = index(buf, '>'))) {          /* address in <> ? */
  	  *p = '\0';                        /* let string end here */
  	  p = index(buf, '<') + 1;          /* and start copy here */
--- 215,224 ----
  
    cont = tome = 0;
    while (fgets(buf, sizeof(buf), stdin) && *buf != '\n')
!     switch(toupper(*buf)) {
      case 'F':		/* "From: " or "From "*/
        cont = 0;
!       if (!strncasecmp(buf, "From:", 5)) {     /* "From:" */
  	if ((p = index(buf, '>'))) {          /* address in <> ? */
  	  *p = '\0';                        /* let string end here */
  	  p = index(buf, '<') + 1;          /* and start copy here */
***************
*** 236,242 ****
  	printd (logline);
  #endif
        }
!       else if (!strncmp(buf, "From ", 5)) { /* "From " */  
  	for (p = buf + 5; *p && *p != ' '; ++p);
  	*p = '\0';
  	(void)strcpy(uucpfrom, buf + 5);  /* this contains a bang path */
--- 236,242 ----
  	printd (logline);
  #endif
        }
!       else if (!strncasecmp(buf, "From ", 5)) { /* "From " */  
  	for (p = buf + 5; *p && *p != ' '; ++p);
  	*p = '\0';
  	(void)strcpy(uucpfrom, buf + 5);  /* this contains a bang path */
***************
*** 271,277 ****
        break;
      case 'R':		/* "Reply-To: " */
        cont = 0;
!       if (!strncmp(buf, "Reply-To:", 9)) { /* much simpler than From: */
  	for (p = buf + 10; *p && *p != ' '; ++p);
  	*p = '\0';
  	(void)strcpy(replyto, buf + 10);
--- 271,277 ----
        break;
      case 'R':		/* "Reply-To: " */
        cont = 0;
!       if (!strncasecmp(buf, "Reply-To:", 9)) { /* much simpler than From: */
  	for (p = buf + 10; *p && *p != ' '; ++p);
  	*p = '\0';
  	(void)strcpy(replyto, buf + 10);
***************
*** 287,293 ****
        break;
      case 'S':		/* "Subject" */
        cont = 0;
!       if (!strncmp(buf, "Subject:", 8)) {
  	(void)strcpy(subject, buf + 9);
  	if ((p = index(subject, '\n')))
  	  *p = '\0';
--- 287,293 ----
        break;
      case 'S':		/* "Subject" */
        cont = 0;
!       if (!strncasecmp(buf, "Subject:", 8)) {
  	(void)strcpy(subject, buf + 9);
  	if ((p = index(subject, '\n')))
  	  *p = '\0';
***************
*** 315,326 ****
  	exit(0);
        break;
      case 'C':		/* "Cc:" */
!       if (strncmp(buf, "Cc:", 3))
  	break;
        cont = 1;
        goto findme;
      case 'T':		/* "To:" */
!       if (strncmp(buf, "To:", 3))
  	break;
        cont = 1;
        goto findme;
--- 315,326 ----
  	exit(0);
        break;
      case 'C':		/* "Cc:" */
!       if (strncasecmp(buf, "Cc:", 3))
  	break;
        cont = 1;
        goto findme;
      case 'T':		/* "To:" */
!       if (strncasecmp(buf, "To:", 3))
  	break;
        cont = 1;
        goto findme;
***************
*** 355,363 ****
  int nsearch(register char *name, register char *str)
  {
    register int len;
  
    for (len = strlen(name); *str; ++str)
!     if (*str == *name && !strncasecmp(name, str, len))
        return(1);
    return(0);
  }
--- 355,365 ----
  int nsearch(register char *name, register char *str)
  {
    register int len;
+   register char c;
+   c=tolower(*name);
  
    for (len = strlen(name); *str; ++str)
!     if (tolower(*str) == c && !strncasecmp(name, str, len))
        return(1);
    return(0);
  }

--Multipart_Tue_Jan_11_12:18:35_2000-1--

